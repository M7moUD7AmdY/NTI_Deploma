/*****************************************************************/
/*                      Author : Moamen Mamdouh Thabet           */
/*                      Date   : 16/11/2022                      */
/*                      Module : TIMER_prog                      */
/*                      Layer  : MCAL                            */
/*                      Version:  1.0                            */
/*****************************************************************/

#include "../../SERVICE/STD_types.h"
#include "../../SERVICE/BIT_math.h"
#include "Timer1_int.h"
#include "Timer1_private.h"
#include "Timer1_config.h"

static void (*TIMER1_OV_CallBack) (void);
static void (*TIMER1_CTCA_CallBack) (void);
static void (*TIMER1_CTCB_CallBack) (void);
static void (*TIMER1_ICU_CallBack) (void);


void TIMER1A_voidInit(void)
{
	/* Select timer mode    */
	#if TIMER1_MODE ==  TIMER1_NORMAL      // time over flow mode
		CLEAR_BIT(TCCR1A ,TCCR1A_WGM10);
		CLEAR_BIT(TCCR1A ,TCCR1A_WGM11);
		CLEAR_BIT(TCCR1B ,TCCR1B_WGM12);
		CLEAR_BIT(TCCR1B ,TCCR1B_WGM13);
	#elif TIMER1_MODE ==TIMER1_PWM_PHASE_CORRECT_8_BIT
	    SET_BIT(TCCR1A ,TCCR1A_WGM10);
	#elif TIMER1_MODE ==TIMER1_PWM_PHASE_CORRECT_9_BIT
	    SET_BIT(TCCR1A ,TCCR1A_WGM11);
	#elif TIMER1_MODE ==TIMER1_PWM_PHASE_CORRECT_10_BIT
	    SET_BIT(TCCR1A ,TCCR1A_WGM10);
	    SET_BIT(TCCR1A ,TCCR1A_WGM11);
	#elif TIMER1_MODE ==TIMER1_CTC
	    SET_BIT(TCCR1B ,TCCR1B_WGM12);
	#elif TIMER1_MODE ==TIMER1_FAST_PWM_8_BIT
	   SET_BIT(TCCR1A ,TCCR1A_WGM10);
	   SET_BIT(TCCR1B ,TCCR1B_WGM12);
	#elif TIMER1_MODE ==TIMER1_FAST_PWM_9_BIT
	   SET_BIT(TCCR1A ,TCCR1A_WGM11);
	   SET_BIT(TCCR1B ,TCCR1B_WGM12);
	#elif TIMER1_MODE ==TIMER1_FAST_PWM_10_BIT
	    SET_BIT(TCCR1A ,TCCR1A_WGM10);
	    SET_BIT(TCCR1A ,TCCR1A_WGM11);
	    SET_BIT(TCCR1B ,TCCR1B_WGM12);
	#elif TIMER1_MODE ==TIMER1_PWM_PHASE_FREQUENCY_CORRECT_ICR1
		SET_BIT(TCCR1B ,TCCR1B_WGM13);
	#elif TIMER1_MODE ==TIMER1_PWM_PHASE_FREQUENCY_CORRECT_OCR1A
	    SET_BIT(TCCR1A ,TCCR1A_WGM10);
	    SET_BIT(TCCR1B ,TCCR1B_WGM13);
	#elif TIMER1_MODE ==TIMER1_PWM_PHASE_CORRECT_ICR1
	    SET_BIT(TCCR1A ,TCCR1A_WGM11);
	    SET_BIT(TCCR1B ,TCCR1B_WGM13);
	#elif TIMER1_MODE ==TIMER1_PWM_PHASE_CORRECT_OCR1A
	    SET_BIT(TCCR1A ,TCCR1A_WGM10);
	    SET_BIT(TCCR1A ,TCCR1A_WGM11);
	    SET_BIT(TCCR1B ,TCCR1B_WGM13);
	#elif TIMER1_MODE ==TIMER1_CTC_ICR1
	   SET_BIT(TCCR1B ,TCCR1B_WGM12);
	   SET_BIT(TCCR1B ,TCCR1B_WGM13);
	#elif TIMER1_MODE ==TIMER1_FAST_PWM_ICR1
	   SET_BIT(TCCR1A ,TCCR1A_WGM11);
	   SET_BIT(TCCR1B ,TCCR1B_WGM12);
	   SET_BIT(TCCR1B ,TCCR1B_WGM13);
	#elif TIMER1_MODE ==TIMER1_FAST_PWM_OCR1A
	   SET_BIT(TCCR1A ,TCCR1A_WGM10);
	   SET_BIT(TCCR1A ,TCCR1A_WGM11);
	   SET_BIT(TCCR1B ,TCCR1B_WGM12);
	   SET_BIT(TCCR1B ,TCCR1B_WGM13);
	#endif
	
	
	/* Set Prescaler Clock Select  */
	#if TIMER1_PRESCALER == TIMER1_DIV_BY_1 
		SET_BIT(TCCR1B , TCCR1B_CS10);
		CLEAR_BIT(TCCR1B , TCCR1B_CS10);
		CLEAR_BIT(TCCR1B , TCCR1B_CS10);
		
	#elif TIMER1_PRESCALER == TIMER1_DIV_BY_8 
		CLEAR_BIT(TCCR1B , TCCR1B_CS10);
		SET_BIT(TCCR1B , TCCR1B_CS11);
		CLEAR_BIT(TCCR1B , TCCR1B_CS12);
		
	#elif TIMER1_PRESCALER == TIMER1_DIV_BY_64 
		SET_BIT(TCCR1B , TCCR1B_CS10);
		SET_BIT(TCCR1B , TCCR1B_CS11);
		CLEAR_BIT(TCCR1B , TCCR1B_CS12);
		
	#elif TIMER1_PRESCALER == TIMER1_DIV_BY_256 
		CLEAR_BIT(TCCR1B , TCCR1B_CS10);
		CLEAR_BIT(TCCR1B , TCCR1B_CS11);
		SET_BIT(TCCR1B , TCCR1B_CS12);
		
	#elif TIMER1_PRESCALER == TIMER1_DIV_BY_1024  
		SET_BIT(TCCR1B , TCCR1B_CS10);
		CLEAR_BIT(TCCR1B , TCCR1B_CS11);
		SET_BIT(TCCR1B , TCCR1B_CS12);
	#endif
	
	
	/*   Action event on ISR       */
	#if TIMER1_COM_EVENT == TIMER1_NO_ACTION 
		CLEAR_BIT(TCCR1A , TCCR1A_COM1A0);
		CLEAR_BIT(TCCR1A , TCCR1A_COM1A1);	
	#elif TIMER1_COM_EVENT == TIMER1_TOGGLE 
		SET_BIT(TCCR1A , TCCR1A_COM1A0);
		CLEAR_BIT(TCCR1A , TCCR1A_COM1A1);
	#elif TIMER1_COM_EVENT ==  TIMER1_NON_INVERTED   // or Clear on compare  CTC mode  and Set on high level
		CLEAR_BIT(TCCR1A , TCCR1A_COM1A0);
		SET_BIT(TCCR1A , TCCR1A_COM1A1);
	#elif TIMER1_COM_EVENT ==  TIMER1_INVERTED   // set on compare  CTC mode  and set on clear on high level
		SET_BIT(TCCR1A , TCCR1A_COM1A0);
		SET_BIT(TCCR1A , TCCR1A_COM1A1);
	#endif
	
	/*Disable Interrupts*/
	CLEAR_BIT(TIMSK , TIMSK_TOIE1);	
	CLEAR_BIT(TIMSK , TIMSK_OCIE1A);
	/*CLEAR FLAGS*/
	SET_BIT(TIFR , TIFR_TOV1);	
	SET_BIT(TIFR , TIFR_OCF1A);
	/*Clear register*/
	TCNT1 = 0 ;
	OCR1A = 0 ;
}

void TIMER1B_voidInit(void)
{
	/* Select timer mode    */
	#if TIMER1B_MODE ==  TIMER1_NORMAL      // time over flow mode
	CLEAR_BIT(TCCR1A ,TCCR1A_WGM10);
	CLEAR_BIT(TCCR1A ,TCCR1A_WGM11);
	CLEAR_BIT(TCCR1B ,TCCR1B_WGM12);
	CLEAR_BIT(TCCR1B ,TCCR1B_WGM13);
	#elif TIMER1B_MODE ==TIMER1_PWM_PHASE_CORRECT_8_BIT
	SET_BIT(TCCR1A ,TCCR1A_WGM10);
	#elif TIMER1B_MODE ==TIMER1_PWM_PHASE_CORRECT_9_BIT
	SET_BIT(TCCR1A ,TCCR1A_WGM11);
	#elif TIMER1B_MODE ==TIMER1_PWM_PHASE_CORRECT_10_BIT
	SET_BIT(TCCR1A ,TCCR1A_WGM10);
	SET_BIT(TCCR1A ,TCCR1A_WGM11);
	#elif TIMER1B_MODE ==TIMER1_CTC
	SET_BIT(TCCR1B ,TCCR1B_WGM12);
	#elif TIMER1B_MODE ==TIMER1_FAST_PWM_8_BIT
	SET_BIT(TCCR1A ,TCCR1A_WGM10);
	SET_BIT(TCCR1B ,TCCR1B_WGM12);
	#elif TIMER1B_MODE ==TIMER1_FAST_PWM_9_BIT
	SET_BIT(TCCR1A ,TCCR1A_WGM11);
	SET_BIT(TCCR1B ,TCCR1B_WGM12);
	#elif TIMER1B_MODE ==TIMER1_FAST_PWM_10_BIT
	SET_BIT(TCCR1A ,TCCR1A_WGM10);
	SET_BIT(TCCR1A ,TCCR1A_WGM11);
	SET_BIT(TCCR1B ,TCCR1B_WGM12);
	#elif TIMER1B_MODE ==TIMER1_PWM_PHASE_FREQUENCY_CORRECT_ICR1
	SET_BIT(TCCR1B ,TCCR1B_WGM13);
	#elif TIMER1B_MODE ==TIMER1_PWM_PHASE_FREQUENCY_CORRECT_OCR1A
	SET_BIT(TCCR1A ,TCCR1A_WGM10);
	SET_BIT(TCCR1B ,TCCR1B_WGM13);
	#elif TIMER1B_MODE ==TIMER1_PWM_PHASE_CORRECT_ICR1
	SET_BIT(TCCR1A ,TCCR1A_WGM11);
	SET_BIT(TCCR1B ,TCCR1B_WGM13);
	#elif TIMER1B_MODE ==TIMER1_PWM_PHASE_CORRECT_OCR1A
	SET_BIT(TCCR1A ,TCCR1A_WGM10);
	SET_BIT(TCCR1A ,TCCR1A_WGM11);
	SET_BIT(TCCR1B ,TCCR1B_WGM13);
	#elif TIMER1B_MODE ==TIMER1_CTC_ICR1
	SET_BIT(TCCR1B ,TCCR1B_WGM12);
	SET_BIT(TCCR1B ,TCCR1B_WGM13);
	#elif TIMER1B_MODE ==TIMER1_FAST_PWM_ICR1
	SET_BIT(TCCR1A ,TCCR1A_WGM11);
	SET_BIT(TCCR1B ,TCCR1B_WGM12);
	SET_BIT(TCCR1B ,TCCR1B_WGM13);
	#elif TIMER1B_MODE ==TIMER1_FAST_PWM_OCR1A
	SET_BIT(TCCR1A ,TCCR1A_WGM10);
	SET_BIT(TCCR1A ,TCCR1A_WGM11);
	SET_BIT(TCCR1B ,TCCR1B_WGM12);
	SET_BIT(TCCR1B ,TCCR1B_WGM13);
	#endif
	
	
	/* Set Prescaler Clock Select  */
	#if TIMER1B_PRESCALER == TIMER1_DIV_BY_1
	SET_BIT(TCCR1B , TCCR1B_CS10);
	CLEAR_BIT(TCCR1B , TCCR1B_CS10);
	CLEAR_BIT(TCCR1B , TCCR1B_CS10);
	
	#elif TIMER1B_PRESCALER == TIMER1_DIV_BY_8
	CLEAR_BIT(TCCR1B , TCCR1B_CS10);
	SET_BIT(TCCR1B , TCCR1B_CS11);
	CLEAR_BIT(TCCR1B , TCCR1B_CS12);
	
	#elif TIMER1B_PRESCALER == TIMER1_DIV_BY_64
	SET_BIT(TCCR1B , TCCR1B_CS10);
	SET_BIT(TCCR1B , TCCR1B_CS11);
	CLEAR_BIT(TCCR1B , TCCR1B_CS12);
	
	#elif TIMER1B_PRESCALER == TIMER1_DIV_BY_256
	CLEAR_BIT(TCCR1B , TCCR1B_CS10);
	CLEAR_BIT(TCCR1B , TCCR1B_CS11);
	SET_BIT(TCCR1B , TCCR1B_CS12);
	
	#elif TIMER1B_PRESCALER == TIMER1_DIV_BY_1024
	SET_BIT(TCCR1B , TCCR1B_CS10);
	CLEAR_BIT(TCCR1B , TCCR1B_CS11);
	SET_BIT(TCCR1B , TCCR1B_CS12);
	#endif
	
	
	/*   Action event on ISR       */
	#if TIMER1B_COM_EVENT == TIMER1_NO_ACTION
	CLEAR_BIT(TCCR1A , TCCR1A_COM1B0);
	CLEAR_BIT(TCCR1A , TCCR1A_COM1B1);
	#elif TIMER1B_COM_EVENT == TIMER1_TOGGLE
	SET_BIT(TCCR1A , TCCR1A_COM1B0);
	CLEAR_BIT(TCCR1A , TCCR1A_COM1B1);
	#elif TIMER1B_COM_EVENT ==  TIMER1_NON_INVERTED   // or Clear on compare  CTC mode  and Set on high level
	CLEAR_BIT(TCCR1A , TCCR1A_COM1B0);
	SET_BIT(TCCR1A , TCCR1A_COM1B1);
	#elif TIMER1B_COM_EVENT ==  TIMER1_INVERTED   // set on compare  CTC mode  and set on clear on high level
	SET_BIT(TCCR1A , TCCR1A_COM1B0);
	SET_BIT(TCCR1A , TCCR1A_COM1B1);
	#endif
	
	/*Disable Interrupts*/
	CLEAR_BIT(TIMSK , TIMSK_TOIE1);
	CLEAR_BIT(TIMSK , TIMSK_OCIE1B);
	/*CLEAR FLAGS*/
	SET_BIT(TIFR , TIFR_TOV1);
	SET_BIT(TIFR , TIFR_OCF1B);
	/*Clear register*/
	TCNT1 = 0 ;
	OCR1B = 0 ;
}

void TIMER1ICU_voidInit(void)
{
	/* Select timer mode    */
	#if TIMER1ICU_MODE ==  TIMER1_NORMAL      // time over flow mode
	CLEAR_BIT(TCCR1A ,TCCR1A_WGM10);
	CLEAR_BIT(TCCR1A ,TCCR1A_WGM11);
	CLEAR_BIT(TCCR1B ,TCCR1B_WGM12);
	CLEAR_BIT(TCCR1B ,TCCR1B_WGM13);
	#elif TIMER1ICU_MODE ==TIMER1_PWM_PHASE_CORRECT_8_BIT
	SET_BIT(TCCR1A ,TCCR1A_WGM10);
	#elif TIMER1ICU_MODE ==TIMER1_PWM_PHASE_CORRECT_9_BIT
	SET_BIT(TCCR1A ,TCCR1A_WGM11);
	#elif TIMER1ICU_MODE ==TIMER1_PWM_PHASE_CORRECT_10_BIT
	SET_BIT(TCCR1A ,TCCR1A_WGM10);
	SET_BIT(TCCR1A ,TCCR1A_WGM11);
	#elif TIMER1ICU_MODE ==TIMER1_CTC
	SET_BIT(TCCR1B ,TCCR1B_WGM12);
	#elif TIMER1ICU_MODE ==TIMER1_FAST_PWM_8_BIT
	SET_BIT(TCCR1A ,TCCR1A_WGM10);
	SET_BIT(TCCR1B ,TCCR1B_WGM12);
	#elif TIMER1ICU_MODE ==TIMER1_FAST_PWM_9_BIT
	SET_BIT(TCCR1A ,TCCR1A_WGM11);
	SET_BIT(TCCR1B ,TCCR1B_WGM12);
	#elif TIMER1ICU_MODE ==TIMER1_FAST_PWM_10_BIT
	SET_BIT(TCCR1A ,TCCR1A_WGM10);
	SET_BIT(TCCR1A ,TCCR1A_WGM11);
	SET_BIT(TCCR1B ,TCCR1B_WGM12);
	#elif TIMER1ICU_MODE ==TIMER1_PWM_PHASE_FREQUENCY_CORRECT_ICR1
	SET_BIT(TCCR1B ,TCCR1B_WGM13);
	#elif TIMER1ICU_MODE ==TIMER1_PWM_PHASE_FREQUENCY_CORRECT_OCR1A
	SET_BIT(TCCR1A ,TCCR1A_WGM10);
	SET_BIT(TCCR1B ,TCCR1B_WGM13);
	#elif TIMER1ICU_MODE ==TIMER1_PWM_PHASE_CORRECT_ICR1
	SET_BIT(TCCR1A ,TCCR1A_WGM11);
	SET_BIT(TCCR1B ,TCCR1B_WGM13);
	#elif TIMER1ICU_MODE ==TIMER1_PWM_PHASE_CORRECT_OCR1A
	SET_BIT(TCCR1A ,TCCR1A_WGM10);
	SET_BIT(TCCR1A ,TCCR1A_WGM11);
	SET_BIT(TCCR1B ,TCCR1B_WGM13);
	#elif TIMER1ICU_MODE ==TIMER1_CTC_ICR1
	SET_BIT(TCCR1B ,TCCR1B_WGM12);
	SET_BIT(TCCR1B ,TCCR1B_WGM13);
	#elif TIMER1ICU_MODE ==TIMER1_FAST_PWM_ICR1
	SET_BIT(TCCR1A ,TCCR1A_WGM11);
	SET_BIT(TCCR1B ,TCCR1B_WGM12);
	SET_BIT(TCCR1B ,TCCR1B_WGM13);
	#elif TIMER1ICU_MODE ==TIMER1_FAST_PWM_OCR1A
	SET_BIT(TCCR1A ,TCCR1A_WGM10);
	SET_BIT(TCCR1A ,TCCR1A_WGM11);
	SET_BIT(TCCR1B ,TCCR1B_WGM12);
	SET_BIT(TCCR1B ,TCCR1B_WGM13);
	#endif
	
	
	/* Set Prescaler Clock Select  */
	#if TIMER1ICU_PRESCALER == TIMER1_DIV_BY_1
	SET_BIT(TCCR1B , TCCR1B_CS10);
	CLEAR_BIT(TCCR1B , TCCR1B_CS10);
	CLEAR_BIT(TCCR1B , TCCR1B_CS10);
	
	#elif TIMER1ICU_PRESCALER == TIMER1_DIV_BY_8
	CLEAR_BIT(TCCR1B , TCCR1B_CS10);
	SET_BIT(TCCR1B , TCCR1B_CS11);
	CLEAR_BIT(TCCR1B , TCCR1B_CS12);
	
	#elif TIMER1ICU_PRESCALER == TIMER1_DIV_BY_64
	SET_BIT(TCCR1B , TCCR1B_CS10);
	SET_BIT(TCCR1B , TCCR1B_CS11);
	CLEAR_BIT(TCCR1B , TCCR1B_CS12);
	
	#elif TIMER1ICU_PRESCALER == TIMER1_DIV_BY_256
	CLEAR_BIT(TCCR1B , TCCR1B_CS10);
	CLEAR_BIT(TCCR1B , TCCR1B_CS11);
	SET_BIT(TCCR1B , TCCR1B_CS12);
	
	#elif TIMER1ICU_PRESCALER == TIMER1_DIV_BY_1024
	SET_BIT(TCCR1B , TCCR1B_CS10);
	CLEAR_BIT(TCCR1B , TCCR1B_CS11);
	SET_BIT(TCCR1B , TCCR1B_CS12);
	#endif
	
	/* ICU NOISE CANSELLER        */
	#if   TIMER1ICU_NOISE_CANSELLER_MODE  ==  ICU_NOISE_CANSELLER_ENABLE
	SET_BIT(TCCR1B,TCCR1B_ICNC1);
	#elif TIMER1ICU_NOISE_CANSELLER_MODE  ==  ICU_NOISE_CANSELLER_DISABLE
	CLEAR_BIT(TCCR1B,TCCR1B_ICNC1);
	#endif
	/*  Input Capture Edge Select */
	#if   TIMER1ICU_EDGE_SELECT  ==   ICU_RAISING_EDGE
	SET_BIT(TCCR1B,TCCR1B_ICES1);
	#elif TIMER1ICU_EDGE_SELECT  ==   ICU_FALLING_EDGE
	CLEAR_BIT(TCCR1B,TCCR1B_ICES1);
	#endif
	
	/*Disable Interrupts*/
	CLEAR_BIT(TIMSK , TIMSK_TOIE1);
	CLEAR_BIT(TIMSK , TIMSK_TICIE1);
	/*CLEAR FLAGS*/
	SET_BIT(TIFR , TIFR_TOV1);
	SET_BIT(TIFR , TIFR_ICF1);
	/*Clear register*/
	TCNT1 = 0 ;
	ICR1 = 0 ;
}

void TIMER1_voidSetTimerReg(u16 Copy_u16Val)
{
	TCNT1 = Copy_u16Val ;
}

void TIMER1A_voidSetCompareVal(u16 Copy_u16Val)
{
	OCR1A = Copy_u16Val ;
}

void TIMER1B_voidSetCompareVal(u16 Copy_u16Val)
{
	OCR1B = Copy_u16Val ;
}

void TIMER1ICU_voidSetICRVal(u16 Copy_u16Val)
{
	ICR1 = Copy_u16Val ;
}

u16 TIMER1ICU_u16ReadICRVal(void)
{
	return ICR1;
}

void TIMER1_voidEnableOVInt(void)
{
	SET_BIT(TIMSK , TIMSK_TOIE1);                   // for enable interrupt overflow  mode
}

void TIMER1_voidDisableOVInt(void)
{
	CLEAR_BIT(TIMSK , TIMSK_TOIE1);
}

void TIMER1A_voidEnableCTCInt(void)
{
	SET_BIT(TIMSK , TIMSK_OCIE1A);
}

void TIMER1A_voidDisableCTCInt(void)
{
	CLEAR_BIT(TIMSK , TIMSK_OCIE1A);
}

void TIMER1B_voidEnableCTCInt(void)
{
	SET_BIT(TIMSK , TIMSK_OCIE1B);
}

void TIMER1B_voidDisableCTCInt(void)
{
	CLEAR_BIT(TIMSK , TIMSK_OCIE1B);
}

void TIMER1ICU_voidEnableCTCInt(void)
{
	SET_BIT(TIMSK , TIMSK_TICIE1);
}

void TIMER1ICU_voidDisableCTCInt(void)
{
	CLEAR_BIT(TIMSK , TIMSK_TICIE1);
}


u16 TIMER1_u16GetTimerReading(void)
{
	return TCNT1;
}

void TIMER1_voidSetOVCallBack(void (*Copy_ptr) (void) ) 
{
	TIMER1_OV_CallBack = Copy_ptr ;
}

void TIMER1A_voidSetCTCCallBack(void (*Copy_ptr) (void) ) 
{
	TIMER1_CTCA_CallBack = Copy_ptr ;
	
}

void TIMER1B_voidSetCTCCallBack(void (*Copy_ptr) (void) )
{
	TIMER1_CTCB_CallBack = Copy_ptr ;
	
}
void TIMER1ICU_voidSetCallBack(void (*Copy_ptr) (void) )
{
	TIMER1_ICU_CallBack = Copy_ptr ;
	
}

void __vector_9(void) __attribute__((signal)); // for avr gcc
void __vector_9(void)
{
	
	TIMER1_OV_CallBack();
}

void __vector_8(void) __attribute__((signal));
void __vector_8(void)
{
	TIMER1_CTCB_CallBack();
}

void __vector_7(void) __attribute__((signal));
void __vector_7(void)
{
	TIMER1_CTCA_CallBack();
}

void __vector_6(void) __attribute__((signal));
void __vector_6(void)
{
	TIMER1_ICU_CallBack();
}
